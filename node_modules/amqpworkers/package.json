{
  "name": "amqpworkers",
  "version": "0.0.1",
  "description": "amqpworkers",
  "main": "index.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/lightsofapollo/amqpworkers.git"
  },
  "author": {
    "name": "James Lal [:lightsofapollo]"
  },
  "license": "Apache2",
  "bugs": {
    "url": "https://github.com/lightsofapollo/amqpworkers/issues"
  },
  "devDependencies": {
    "mocha": "~1.15.1",
    "blanket": "~1.1.5",
    "amqplib": "~0.1.1",
    "mocha-as-promised": "~2.0.0"
  },
  "peerDependencies": {
    "amqplib": ">= 0.1.1"
  },
  "dependencies": {
    "debug": "~0.7.4",
    "promise": "~3.2.0"
  },
  "readme": "# AMQP Workers\n\n[![Build Status](https://travis-ci.org/lightsofapollo/amqpworkers.png)](https://travis-ci.org/lightsofapollo/amqpworkers)\n\nAMQP Workers is an opinioned library which codifies a lot of my personal\ntastes while working with AMQP in JavaScript (node). It also embraces a\nPromise _only_ api (everything should return a promise) and requires you\nto setup / manage your own amqp connection (through [amqplib](https://npmjs.org/package/amqplib)).\n\nThe primary export is build out of four smaller modules (and while you\ncan use the top level export using the longer form is probably what you\nwant).\n\n- [Schema](#schema)\n- [Consumer](#consumer)\n- [Message](#message)\n- [Publisher](#publisher)\n\n\n## Schema\n\nA \"Schema\" is a blueprint to build all queues, exchanges and bindings\nbetween them. Generally you always need to define a schema and its a\ngood idea to try to build it before publishing new messages or consuming\na queue. \n\n```js\n\n// your_schema.js\n\nvar Schema = require('amqpworkers/schema');\n\nmodule.exports = new Schema({\n  // see examples/schema_config.json\n});\n\n```\n\nNow that the schema is defined we can use it to define, purge and\ndestroy it. In RabbitMQ 3.2 and greater all are idempotent but deletes\nwill fail if the queue/exchange does not exist in earlier versions.\n\n```js\n// Define the schema\n\nvar AMQPSchema = require('./my_schema');\n\n// this is the result from amqplib.connect\nvar connection;\n\nAMQPSchema.define(connection).then(\n //\n);\n\n// Destroy the schema (delete queues and exchanges)\n\nAMQPSchema.destroy(connection).then(\n // messages and queues are gone! Good for testing\n);\n\n// Purge the messages but leave the exchanges, queues and bindings alone\n\nAMQPSchema.purge(connection).then(\n // messages and queues are gone! Good for testing\n);\n```\n\n## Consumer\n\nA consumer is an object oriented approach to consuming queues. They can\nbe used directly by instantiating Consumer or via inheritance.\n\n```js\nvar Consumer = require('amqpworkers/consumer');\n\n// this is the result from amqplib.connect\nvar connection;\n\nvar consumer = new Consumer(queue);\n\n// Read will be called when an item is being consumed from the queue.\nconsumer.read = function(content, message) {\n  // content is the parsed content of the message\n  // and message is un mutated value from amqplib\n\n\n  // the promise is optional but highly recommended if you care about\n  // ack / nack. When this promise is accepted an ack will be sent\n  // (and you guessed! nack when rejected).\n  return new Promise(function(accept, reject) {\n\n  });\n}\nconsumer.consume('the queue name', {\n  // optional prefetch option\n  prefetch: 1\n});\n\n// cleanup when your done\nconsumer.close();\n```\n\nThe consumer has the `parseMessage` method which will be called prior\nto passing the result of that function and the message along to the\n.read method. This can be used as a hook for implementing other\nde-serializing protocols.\n\n## Message\n\nA message is a simple representation of an _outbound_ (to be published)\nmessage.\n\nMessages are simply any object with a `.buffer [Buffer]` property and an `.options [Object]` property.\nThe provided object will parse objects into json blobs\n`(new Buffer(JSON.stringify(obj))` and stamp them with `contentType`\n`application/json`\n\n```js\nvar Message = require('amqp/message');\n\nvar myMsg = new Message(\n  // will be converted into a buffer\n  { woot: true },\n\n  // see amqplib #publish options\n  { persistent: true }\n);\n\n// json blob\nmyMsg.buffer;\n\n// application/json\nmyMsg.options.contentType;\n```\n\nMessages are only useful in conjunction with [Publishers](#publisher)\n`#publish` method.\n\n## Publisher\n\nPublishers are fairly simple wrappers around #publish and confirm\nchannels. The assumption is that every message is critical and slowing\ndown the publishing process to confirm writes is more important then\nraw speed.\n\n```js\nvar Publisher = require('amqpworker/publisher'),\n    Message = require('amqpworker/message');\n\n// from amqplib #connect\nvar connection;\n\nvar tasks = new Publisher(connection);\n\n// publish something to the task exchange\n\ntasks.publish(\n  'tasks', // exchange name\n  'request', // routing key\n  new Message({ woot: true }, { persistent: true })\n).then(\n  function() {\n    // confirmed  \n  },\n  function() {\n    // rejected\n  }\n);\n\n// cleanup when your done\ntasks.close();\n```\n",
  "readmeFilename": "README.md",
  "_id": "amqpworkers@0.0.1",
  "dist": {
    "shasum": "6d98e5473fdc386d7cc7db2fce6c21e5f6e43b12"
  },
  "_from": "amqpworkers@",
  "_resolved": "https://registry.npmjs.org/amqpworkers/-/amqpworkers-0.0.1.tgz"
}
