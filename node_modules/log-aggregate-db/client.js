var Promise = require('promise'),
    TransformStream = require('stream').Transform,
    promiseProxy = require('proxied-promise-object'),
    QueryStream = require('pg-query-stream');

var FIND_CONTENT = 'SELECT content, "offset" FROM log_aggregate_db.parts ' +
               'WHERE "entitiesId" = $1';

var STARTING_OFFSET = '(SELECT 1 "offset" FROM log_aggregate_db.parts ' +
                        'WHERE "offset" <= $2 LIMIT 1)';

var SQL = {
  deleteParts: 'DELETE FROM log_aggregate_db.parts WHERE "entitiesId" = $1',

  insertPart: 'INSERT INTO log_aggregate_db.parts ' +
                '("entitiesId", "offset", length, content, "createdAt") ' +
              'VALUES ' +
                '($1, $2, $3, $4, NOW())',

  findContent: FIND_CONTENT + ' ORDER BY "offset"',

  findContentRanged: 'SELECT content, "offset" FROM log_aggregate_db.parts' +
               ' WHERE "entitiesId" = $1 AND "offset" >= ' + STARTING_OFFSET +
               ' ORDER BY "offset"'
};

function ContentStream(options) {
  this.offset = options.offset || 0;

  TransformStream.call(this);
  // Sorta hacky but the idea is we get written to by objects and the
  // stream outputs binary.
  this._writableState.objectMode = true;
}

ContentStream.prototype = {
  __proto__: TransformStream.prototype,

  /**
  When true _transform needs to perform a part offset check / slice (only used
  by the first transform call).
  */
  _partOffsetCheck: true,

  /**
  Starting offset
  */
  offset: 0,

  _transform: function(chunk, encoding, done) {
    var buffer = chunk.content;

    // the offset can be in the middle of one of our rows so we might
    // need to trim it down a bit
    if (this._partOffsetCheck) {
      // we only check once... The query itself should get us within a
      // single row of where to cut.
      this._partOffsetCheck = false;

      var partOffset = chunk.offset;
      // our current part offset requires trimming
      if (this.offset > partOffset) {
        buffer = buffer.slice(this.offset - partOffset);
      }
    }

    this.push(buffer);
    done();
  }
};

function Client(db) {
  this.db = promiseProxy(Promise, db);
}

Client.prototype = {
  /**
  Insert a piece of the stream into a particular entity.

  XXX: We don't have a use case for streaming a series of parts as one
       transaction so there is no way to do this right now.

  @param {Number} id of entity (returned by create)
  @param {Number} offset of the buffer.
  @param {Number} length (in bytes) of the buffer.
  @param {String|Buffer} buffer content to insert.
  @return {Promise}
  */
  add: function(id, offset, length, buffer) {
    return this.db.query(SQL.insertPart, [
      id,
      offset,
      length,
      buffer
    ]);
  },

  /**
  Delete an entity and all of its parts.
  */
  delete: function(id) {
    return this.db.query(SQL.deleteParts, [id]);
  },

  /**
  Fetches the content of a particular entity starting from an offset

  @param {Number} id of entity.
  @param {Number} [startingOffset=0] (inclusive) starting offset in the stream.
  @return {ReadableStream} readable stream to consume from.
  */
  content: function(id, startingOffset) {
    startingOffset = startingOffset || 0;
    // transform our rows into a binary stream
    var contentStream = new ContentStream({
      offset: startingOffset
    });

    var query;
    var values = [id];

    // two distinct search cases
    if (startingOffset <= 0) {
      // find the entire document
      query = SQL.findContent;
    } else {
      // find a subset of the document (starting from offset N)
      query = SQL.findContentRanged;
      values.push(startingOffset);
    }

    var stream = new QueryStream(query, values);

    stream.pipe(contentStream);
    this.db.query(stream);

    return contentStream;
  }
};

module.exports = Client;
