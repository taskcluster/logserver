suite('client', function() {
  var db = require('./test/db')();
  var Client = require('./client');
  var Promise = require('promise');
  var uuid = require('uuid');

  var subject;
  setup(function() {
    subject = new Client(db.client);
  });

  suite('#delete', function() {
    var id = uuid.v4();
    setup(function() {
      return subject.add(id, 0, 1, new Buffer('x'));
    });

    setup(function() {
      return subject.delete(id);
    });

    test('has no content', function(done) {
      var stream = subject.content(id);
      stream.on('data', function(data) {
        done(new Error('should not have data'));
      });
      stream.on('end', done);
    });
  });

  suite('#add', function() {
    var id = uuid.v4();;
    var buffer = new Buffer('woot!');

    setup(function() {
      return subject.add(id, 0, buffer.length, buffer);
    });

    test('part is added', function() {
      var query =
        'SELECT * FROM log_aggregate_db.parts WHERE "entitiesId" = $1';

      return db.client.query(query, [id]).then(
        function(result) {
          assert.ok(result);
          assert.equal(result.rowCount, 1);

          var row = result.rows[0];
          assert.equal(row.offset, 0);
          assert.equal(row.length, buffer.length);
          assert.equal(buffer.toString(), row.content.toString());
        }
      );
    });
  });

  suite('#content', function() {
    var id = uuid.v4();
    var parts = [
      new Buffer('i am the first.\n'),
      new Buffer('i am the second.\n'),
      new Buffer('i am the third.\n')
    ];

    var expectedFinalBuffer = Buffer.concat(parts);

    // we need to add some parts to the entity
    setup(function() {
      var promises = [];
      var offset = 0;
      parts.forEach(function(part) {
        var length = part.length;
        promises.push(subject.add(
          id,
          offset,
          length,
          part
        ));
        offset += length;
      });

      return Promise.all(promises);
    });

    test('stream from the middle of a chunk to the end', function(done) {
      // Everything fits into a single byte so we can slice randomly
      // like this.. The expectation is the actual rendering will be
      // done by something that can buffer incomplete utf8.
      var offset = Math.floor(expectedFinalBuffer.length / 2);
      var expected = expectedFinalBuffer.slice(offset);

      var stream = subject.content(id, offset);
      var buffers = [];
      stream.on('data', function(buffer) {
        buffers.push(buffer);
      });

      stream.on('end', function() {
        var joined = Buffer.concat(buffers);
        assert.equal(
          joined.toString(),
          expected.toString()
        );
        done();
      });
    });

    test('stream from begining', function(done) {
      var stream = subject.content(id);
      var buffers = [];
      stream.on('data', function(buffer) {
        buffers.push(buffer);
      });

      stream.on('end', function() {
        var joined = Buffer.concat(buffers);

        assert.equal(joined.length, expectedFinalBuffer.length);
        assert.equal(
          joined.toString(),
          expectedFinalBuffer.toString()
        );
        done();
      });
    });
  });
});
